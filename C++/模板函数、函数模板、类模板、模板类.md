### 一、类模板与模板类
* 类模板       
````
类模板的重点是模板。表示的是一个模板，专门用于产生类的模子。例如：  
template <typename T>
class Vector
{
     ...
};

使用这个Vector模板就可以产生很多的class(类)
                                      Vector<int>、Vector<char>、 Vector<   Vector<int>  >、Vector<Shape*>......
````

* 模板类

      模板类的重点是类。表示的是由一个模板生成而来的类。例如：上面的Vector<int>、Vector<char>、...... 全是模板类。
`In order for the compiler to generate the code, it must see both the  template definition (not just declaration) 
and the specific types/whatever used to "fill in" the template. For example, if you're trying to use a Foo<int>, 
the compiler must see both the Foo template and the fact that  you're trying to make a specific Foo<int>.`
译文：为了让编译器生成代码，它必须同时看到模板定义（不仅仅是声明）和用于“填充”模板的特定类型/内容。例如，如果您想要使用
Foo<int>的话，编译器必须同时看到Foo模板和您正在尝试制作一个特定的Foo的事实。
     
````
Suppose you have a template Foo defined like this:        译文：假设你有一个像这样定义的模板Foo:
template<class   T>
class Foo 
{
public:
     Foo();
     void someMethod(T x);
private:
    T x;
};


Along with similar definitions for the member functions:   译文：对成员函数的定义：
template<class   T>
Foo<T>::Foo()
{
    ...
}

template<class   T>
void   Foo<T>::someMethod(T   x)
{
    ...
}

Now suppose you have some code in file Bar.cpp that uses Foo<int>:  
译文：现在假设您在文件栏中有一些 Bar.cpp 使用Foo < int >:
//Bar.cpp  
void   blah_blah_blah()  
{  
    ...  
    Foo<int>  f;  
    f.someMethod(5);  
    ...  
}

Clearly somebody somewhere is going to have to use the "pattern" for the  constructor definition and for the 
someMethod() definition and instantiate those when T is actually int. But if you had put the definition of 
the  constructor and someMethod() into file Foo.cpp, the compiler would see the  template code when it 
compiled Foo.cpp and it would see Foo<int> when it  compiled Bar.cpp, but there would never be a time when 
it saw both the  template code and Foo<int>. So by rule above, it could never generate the code for 
Foo<int>::someMethod().
译文：显然，某个地方的某人将不得不使用构造函数定义和someMethod（）定义的“模式”，并在T实际为int时实例化这些定义，
但是如果您已经将构造函数和someMethod（）的定义放入file Foo中。在编译Foo时，编译器会看到模板代码。当它编译了Bar时，
它会看到Foo。cpp，但是永远不会有一个时间，它同时看到了模板代码和Foo。因此，根据上面的规则，
它永远不能生成Foo的代码：：someMethod（）。
````

### 二、函数模板与模板函数
