# 2.9  习题集

## 1. 什么是前趋图？为什么要引入前趋图？

答：前趋图(Precedence Graph)是一个有向无循环图，记为DAG(Directed Acyclic Graph)，用于描述进程之间执行的前后关系。

## 2. 画出下面四条语句的前趋图:

    S1=a：= x + y; 
    S2=b：= z + 1; 
    S3=c：= a – b；
    S4=w：= c + 1;

答：其前趋图为：

## 3. 为什么程序并发执行会产生间断性特征？

答：程序在并发执行时，由于它们共享系统资源，为完成同一项任务需要相互合作，致使这些并发执行的进程之间，形成了相互制约关系，从而使得进程在执行期间出现间断性。

## 4．程序并发执行时为什么会失去封闭性和可再现性？

答：程序并发执行时，多个程序共享系统中的各种资源，因而这些资源的状态由多个程序改变，致使程序运行失去了封闭性，也会导致其失去可再现性。

## 5．在操作系统中为什么要引入进程概念？它会产生什么样的影响?

答：为了使程序在多道程序环境下能并发执行，并对并发执行的程序加以控制和描述，在操作系统中引入了进程概念。

影响: 使程序的并发执行得以实行。

## 6．试从动态性，并发性和独立性上比较进程和程序?

* （1）**动态性**是进程最基本的特性，表现为由创建而产生，由调度而执行，因得不到资源而暂停执行，由撤销而消亡。进程有一定的生命期，而程序只是一组有序的指令集合，是静态实体。

* （2）**并发性**是进程的重要特征，同时也是OS 的重要特征。引入进程的目的正是为了使其程序能和其它进程的程序并发执行，而程序是不能并发执行的。

* （3）**独立性**是指进程实体是一个能独立运行的基本单位，也是系统中独立获得资源和独立调度的基本单位。对于未建立任何进程的程序，不能作为独立单位参加运行。

## 7．试说明PCB 的作用，为什么说PCB 是进程存在的惟一标志？

答：PCB 是进程实体的一部分，是操作系统中最重要的记录型数据结构。作用是使一个在多道程序环境下不能独立运行的程序，成为一个能独立运行的基本单位，成为能与其它进程并发执行的进程。OS是根据PCB对并发执行的进程进行控制和管理的。

### 8．PCB提供了进程管理和进程调度所需的哪些信息？

### 9．进程控制块的组织方式有那几种？

### 10．何为操作系统内核？内核的主要功能是什么？

## 11．试说明进程在三个基本状态之间转换的典型原因。

* （1）就绪状态→执行状态：进程分配到CPU资源

* （2）执行状态→就绪状态：时间片用完

* （3）执行状态→阻塞状态：I/O请求

* （4）阻塞状态→就绪状态：I/O完成

## 12．为什么要引入挂起状态？该状态有哪些性质？

* 引入挂起状态处于五种不同的需要: 
    * 终端用户需要
    * 父进程需要  
    * 操作系统需要
    * 对换需要
    * 负荷调节需要

* 性质：处于挂起状态的进程不能接收处理机调度。

## 13．在进行进程切换时，所要保存的处理机状态信息有哪些？

   >答：进行进程切换时，所要保存的处理机状态信息有：
* （1）进程当前暂存信息
* （2）下一指令地址信息
* （3）进程状态信息
* （4）过程和系统调用参数及调用地址信息。

## 14．试说明引起进程创建的主要事件。

答：引起进程创建的主要事件有：

* 用户登录

* 作业调度

* 提供服务

* 应用请求

## 15．试说明引起进程被撤销的主要事件。

答：引起进程被撤销的主要事件有：正常结束、异常结束（越界错误、保护错、非法指令、特权指令错、运行超时、等待超时、算术运算错、I/O 故障）、外界干预（操作员或操作系统干预、父进程请求、父进程终止）。

## 16．在创建一个进程时所要完成的主要工作是什么？

* （1）OS 发现请求创建新进程事件后，调用进程创建原语Creat()；
* （2）申请空白PCB；
* （3）为新进程分配资源；
* （4）初始化进程控制块；
* （5）将新进程插入就绪队列.

## 17．在撤销一个进程时所要完成的主要工作是什么？

* （1）根据被终止进程标识符，从PCB 集中检索出进程PCB，读出该进程状态。
* （2）若被终止进程处于执行状态，立即终止该进程的执行，置调度标志真，指示该进程被终止后重新调度。
* （3）若该进程还有子进程，应将所有子孙进程终止，以防它们成为不可控进程。
* （4）将被终止进程拥有的全部资源，归还给父进程，或归还给系统。
* （5）将被终止进程PCB 从所在队列或列表中移出，等待其它程序搜集信息。

## 18．试说明引起进程阻塞或被唤醒的主要事件是什么？

* a.请求系统服务；
* b.启动某种操作；
* c.新数据尚未到达；
* d.无新工作可做.

## 19．为什么要在OS中引入线程？

答：在操作系统中引入线程，则是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性，提高CPU的利用率。进程是分配资源的基本单位,而线程则是系统调度的基本单位。

## 20．试说明线程具有哪些属性？

* （1)轻型实体

* （2）独立调度和分派的基本单位

* （3）可并发执行

* （4）共享进程资源。


## 21.试从调度性，并发性，拥有资源及系统开销方面对进程和线程进行比较。

* （1）调度性。线程在OS 中作为调度和分派的基本单位，进程只作为资源拥有的基本单位。
* （2）并发性。进程可以并发执行，一个进程的多个线程也可并发执行。
* （3）拥有资源。进程始终是拥有资源的基本单位，线程只拥有运行时必不可少的资源，本身基本不拥有系统资源，但可以访问隶属进程的资源。
* （4）系统开销。操作系统在创建、撤消和切换进程时付出的开销显著大于线程。

### 22．线程控制块TCB中包含了哪些内容？

### 23．何谓用户级线程和内核支持线程？

* （1）用户级线程：仅存在于用户空间中的线程，无须内核支持。这种线程的创建、撤销、线程间的同步与通信等功能，都无需利用系统调用实现。用户级线程的切换通常发生在一个应用进程的诸多线程之间，同样无需内核支持。

* （2）内核支持线程：在内核支持下运行的线程。无论是用户进程中的线程，还是系统线程中的线程，其创建、撤销和切换等都是依靠内核，在内核空间中实现的。在内核空间里还为每个内核支持线程设置了线程控制块，内核根据该控制块感知某线程的存在并实施控制。

## 24．试说明用户级线程的实现方法。

答：用户级线程是在用户空间中的实现的，运行在“运行时系统”与“内核控制线程”的中间系统上。运行时系统用于管理和控制线程的函数的集合。内核控制线程或轻型进程LWP可通过系统调用获得内核提供服务，利用LWP进程作为中间系统。

## 25．试说明内核支持线程的实现方法。

答：系统在创建新进程时，分配一个任务数据区PTDA，其中包括若干个线程控制块TCB空间。创建一个线程分配一个TCB，有关信息写入TCB，为之分配必要的资源。当PTDA中的TCB 用完，而进程又有新线程时，只要所创建的线程数目未超过系统允许值，系统可在为之分配新的TCB；在撤销一个线程时，也应回收线程的所有资源和TCB。

### 26．多线程模型有哪几种类型？多对一模型有何优缺点？

===================================================================

## 1、简述程序并发执行的特征。

答：程序并发执行的主要特点是并发程序间具有相互制约的关系，程序并发执行失去了程序的封闭性和再现性，程序和机器执行程序的活动不再一一对应。
* 间断性
* 失去封闭性
* 不可再现性

## 2、简述进程的特征。

* 结构特征：进程实体由程序段、数据和PCB组成。在许多情况下所说的进程实际上是进程实体，创建进程即创建进程的PCB，撤消也如此。
* 动态性：进程的实质是进程实体的一次执行过程。因此，动态性是进程的最基本特征。还表现在具有生命周期。
* 并发性：指多个进程实体同存于内存中，且能在一段时间内同时运行。
* 独立性：进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位。
* 异步性：指进程按各自独立的、不可预知的速度向前推进，或者说进程实体按异步方式运行。

## 3、比较进程与程序的主要区别。

* ①程序是有序代码的集合，是一个静态的概念。进程是程序的一次执行过程，是一个动态概念。进程不可以在计算机之间迁移，而程序通常对应着文件，可以复制。
* ②进程是一个状态变化的过程，是有生命期的。而程序是永久的，可以长久保存。
* ③进程与程序的组成不同。进程由程序段、数据段和进程控制块组成，而程序仅是代码的有序集合。
* ④进程与程序是密切相关的。通过多次执行，一个程序可对应多个进程。但进程与它本身所运行的程序只能是一对一的关系。
* ⑤进程更能真实地描述并发，而程序不能。
* ⑥进程可创建其他进程，而程序并不能形成新的程序。

## 4、说明进程的三个基本状态及相应的状态转换图。

* 1)就绪(Ready)状态：其他条件满足，仅差CPU
* 2)执行状态：其他条件满足，也获得CPU
* 3)阻塞状态：等待某种事件发生

  <div align="center"><img src="./img/进程的三种基本状态及其转换.png"/></div>

## 5、引入挂起状态的原因是什么,描述引入挂起状态后的状态转换图。

* (1)终端用户的请求:发现问题希望进程停止以修改。
* (2)父进程请求:父进程挂起子进程为考察修改子进程。
* (3)负荷调节的需要:当负荷较重时，系统实时任务受到影响时，将一些不重要的进程挂起。
* (4)操作系统的需要:以便检查运行中的资源使用情况或进程统计。

  <div align="center"><img src="./img/具有挂起操作的进程状态图.png"/></div>

## 6、引起进程创建和撤销的事件以及步骤分别是什么？(四方面)

* 引起进程创建的事件

    * 1)用户登录。 分时
    * 2)批处理系统中的作业调度。
    * 3)由操作系统创建的系统服务。打印
    * 4)用户启动应用程序。 I-C-P

* 进程创建的步骤

    * 1)申请空白PCB： 申请惟一的数字标识符。
    * 2)为新进程分配资源：主要是内存空间
    * 3)初始化进程控制块：包含标识、处理机状态、处理机控制信息。
    * 4)如果进程就绪队列能够接纳新进程， 便将新进程插入就绪队列。

* 引起进程撤销的事件

    * 1)正常结束
    * 2)异常结束
    * 3)外界干预
        * ①操作员或操作系统干预。 由于某种原因，例如，发生了死锁， 由操作员或操作系统终止该进程；
        * ②父进程请求。 由于父进程具有终止自己的任何子孙进程的权利， 因而当父进程提出请求时，系统将终止该进程；
        * ③父进程终止。 当父进程终止时，OS也将他的所有子孙进程终止。

* 进程撤销的步骤

    * 1)根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态。
    * 2)若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度。
    * 3)若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防他们成为不可控的进程。
    * 4)将被终止进程所拥有的全部资源，或者归还给其父进程， 或者归还给系统。
    * 5)将被终止进程(它的PCB)从所在队列(或链表)中移出， 等待其他程序来搜集信息。

## 7、进程同步机制遵循的准则是什么？

* 1)空闲让进
* 2)忙则等待
* 3)有限等待
* 4)让权等待

## 8、简述进程同步解决方式中信号量数值所表示的意义。

* 整型信号量S的意义：
    * S > 0：表示系统中空闲的该类临界资源的个数。
    * S = 0：表示系统中该类临界资源刚好被全部占用，而且没有进程在等待该临界资源。

## 9、进程的高级通信分类有哪几种？有哪几种实现方式？

* 高级通信分类
    * 共享存储器系统(Shared-Memory System)
    * 管道(Pipe)通信(共享文件通信方式)
    * 消息传递系统(Message passing system)
    * 客户机-服务器系统(Client-Server system)
        * 其主要实现方法分为三类：套接字、远程过程调用和远程方法调用
* 实现方式
    * 直接消息传递系统
    * 信箱通信（间接通信方式)

## 10、为什么要引入线程，简述线程的分类。

* 在操作系统中引入线程，则是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性，提高CPU的利用率。进程是分配资源的基本单位,而线程则是系统调度的基本单位。
* 分类：
    * 内核支持线程KST(Kernel Supported Threads)
    * 用户级线程ULT(User Level Threads)
    * 组合方式
    
===================================================================


### 1．进程在运行时存在哪两种形式的制约？并举例说明之。

* （1）间接相互制约关系。举例：有两进程A 和B，如果A 提出打印请求，系统已把唯一的一台打印机分配给了进程B，则进程A 只能阻塞；一旦B 释放打印机，A 才由阻塞改为就绪。
* （2）直接相互制约关系。举例：有输入进程A 通过单缓冲向进程B 提供数据。当缓冲空时，计算进程因不能获得所需数据而阻塞，当进程A 把数据输入缓冲区后，便唤醒进程B；反之，当缓冲区已满时，进程A 因没有缓冲区放数据而阻塞，进程B 将缓冲区数据取走后便唤醒A。

### 2．为什么进程在进入临界区之前应先执行“进入区”代码？而在退出前又要执行“退出区”代码？

答：为了实现多个进程对临界资源的互斥访问，必须在临界区前面增加一段用于检查欲访问的临界资源是否正被访问的代码，如果未被访问，该进程便可进入临界区对资源进行访问，并设置正被访问标志，如果正被访问，则本进程不能进入临界区，实现这一功能的代码为"进入区"代码；在退出临界区后，必须执行"退出区"代码，用于恢复未被访问标志，使其它进程能再访问此临界资源。

### 3. 同步机构应遵循哪些基本准则？为什么？

答：同步机构应遵循的基本准则是：空闲让进、忙则等待、有限等待、让权等待原因：为实现进程互斥进入自己的临界区。

### 4. 试从物理概念上说明记录型信号量wait 和signal。

答：wait(S)：当S.value>0时，表示目前系统中这类资源还有可用的。执行一次wait 操作，意味着进程请求一个单位的该类资源，使系统中可供分配的该类资源减少一个，因此描述为S.value:=S.value-1；当S.value<0时，表示该类资源已分配完毕，进程应调用block原语自我阻塞，放弃处理机，并插入到信号量链表S.L中。signal(S)：执行一次signal操作，意味着释放一个单位的可用资源，使系统中可供分配的该类资源数增加一个，故执行S.value:=S.value+1 操作。若加1后S.value≤0，则表示在该信号量链表中，仍有等待该资源的进程被阻塞，因此应调用wakeup 原语，将S.L链表中的第一个等待进程唤醒。

### 5．你认为整型信号量机制是否完全遵循了同步机构的四条准则？

答：整型信号量机制不完全遵循同步机制的四条准则，它不满足“让权等待”准则。

### 6．如何利用信号量机制来实现多个进程对临界资源的互斥访问？并举例说明之。

答：为使多个进程互斥访问某临界资源，只需为该资源设置一互斥信号量mutex，并设其初值为1，然后将各进程访问该资源的临界区CS置于wait(mutex)和signal(mutex)操作之间即可。这样，每个欲访问该临界资源的进程在进入临界区之前，都要先对mutex 执行wait 操作，若该资源此刻未被访问，本次wait 操作必然成功，进程便可进入自己的临界区，这时若再有其他进程也欲进入自己的临界区，此时由于对mutex 执行wait操作定会失败，因而该进程阻塞，从而保证了该临界资源能被互斥访问。当访问临界资源的进程退出临界区后，应对mutex执行signal 操作，释放该临界资源。利用信号量实现进程互斥的进程描述如下：

    Var mutex: semaphore:=1；
    begin
    parbegin
    process 1: begin
    repeat
    wait(mutex)；
    critical section
    signal(mutex)；
    remainder section
    until false；
    end
    process 2: begin
    repeat
    wait(mutex)；
    critical section
    signal(mutex)；
    remainder section
    until false；
    end
    parend
 
 
### 7．试写出相应的程序来描述图2-17所示的前驱图。
 
>（a）

    Var a, b, c, d, e, f, g, h; semaphore:= 0, 0,0, 0, 0, 0, 0, 0;
    begin
    parbegin
    begin S1; signal(a); signal(b); end;
    begin wait(a); S2; signal(c); signal(d); end;
    begin wait(b); S3; signal(e); end;
    begin wait(c); S4; signal(f); end;
    begin wait(d); S5; signal(g); end;
    begin wait(e); S6; signal(h); end;
    begin wait(f); wait(g); wait(h); S7; end;
    parend
    end

>（b）

    Var a, b, c, d, e, f, g, h,i,j; semaphore:= 0,0, 0, 0, 0, 0, 0,0,0, 0;
    begin
    parbegin
    begin S1; signal(a); signal(b); end;
    begin wait(a); S2; signal(c); signal(d); end;
    begin wait(b); S3; signal(e); signal(f); end;
    begin wait(c); S4; signal(g); end;
    begin wait(d); S5; signal(h); end;
    begin wait(e); S6; signal(i); end;
    begin wait(f); S7; signal(j); end;
    begin wait(g);wait(h); wait(i); wait(j); S8;end;
    parend
    end

### 8．在生产者消费者问题中，如果缺少了signal(full)或signal(empty),对执行结果有何影响？

答：如果缺少signal(full)，那么表明从第一个生产者进程开始就没有改变信号量full 值，即使缓冲池产品已满，但full值还是0，这样消费者进程执行wait(full)时认为缓冲池是空而取不到产品，消费者进程一直处于等待状态。如果缺少signal(empty)，在生产者进程向n个缓冲区投满产品后消费者进程才开始从中取产品，这时empty=0，full=n，那么每当消费者进程取走一个产品empty值并不改变，直到缓冲池取空了，empty 值也是0，即使目前缓冲池有n 个空缓冲区，生产者进程要想再往缓冲池中投放产品也会因为申请不到空缓冲区被阻塞。

### 9．在生产消费者问题中，如果将两个wait操作即wait(full)和wait(mutex)互换位置，或者将signal(mutex)与signal（full）互换位置，结果如何？

答：将wait(full)和wait(mutex)互换位置后，可能引起死锁。考虑系统中缓冲区全满时，若一生产者进程先执行了wait(mutex)操作并获得成功，则当再执行wait(empty)操作时，它将因失败而进入阻塞状态，它期待消费者进程执行signal(empty)来唤醒自己，在此之前，它不可能执行signal(mutex)操作，从而使试图通过执行wait(mutex)操作而进入自己的临界区的其他生产者和所有消费者进程全部进入阻塞状态，这样容易引起系统死锁。若signal(mutex)和signal(full)互换位置后只是影响进程对临界资源的释放次序，而不会引起系统死锁，因此可以互换位置。

### 10．我们在为某一临界资源设置一把锁W，当W=1时表示关锁，当W=0时表示锁已打开。试写出开锁和关锁的原语，并利用他们实现互斥。

答：整型信号量：

    lock(W): while W=1 do no-op
    W:=1;
    unlock(W): W:=0;
    记录型信号量：lock(W): W:=W+1;
    if(W>1) then block(W, L)
    unlock(W): W:=W-1;
    if(W>0) then wakeup(W, L)
    例子：
    Var W:semaphore:=0；
    begin
    repeat
    lock(W);
    critical section
    unlock(W);
    remainder section
    until false;
    end
 
 

### 11．试修改下面生产者－消费者问题解法中的错误:

>答： producer:

    begin
    repeat
    …
    producer an item in nextp;
    wait(mutex);
    wait(full);
    buffer(in):=nextp;

    signal(mutex);

    until false;
    end

>consumer:

    begin
    repeat
    wait(mutex);
    wait(empty);
    nextc:=buffer(out);
    out:=out+1;
    signal(mutex);
    consumer item in nextc;
    until false;
    end

### 12．试利用记录型信号量写出一个不会出现死锁的哲学家进餐问题的算法.

    Var chopstick:array[0,…,4] of semaphore;
    所有信号量均被初始化为1，第i 位哲学家的活动可描述为：
    Repeat
    Wait(chopstick[i]);
    Wait(. chopstick[(i+1) mod 5]);
    …
    Ea.t ;
    …
    Signal(chopstick[i]);
    Signal(chopstick[(i+1) mod 5])
    Ea.t ;
    …
    Think;
    Until false;
 
 
### 13．在测量控制系统中的数据采集任务，把所采集的数据送一单缓冲区；计算任务从该单缓冲中取出数据进行计算.试写出利用信号量机制实现两者共享单缓冲的同步算法。

>a. Var mutex, empty, full: semaphore:=1, 1, 0;

    gather:
    begin
    repeat
    ……
    gather data in nextp;
    wait(empty);
    wait(mutex);
    buffer:=nextp;
    signal(mutex);
    signal(full);
    until false;
    end
    compute:
    begin
    repeat
    ……
    wait(full);
    wait(mutex);
    nextc:=buffer;
    signal(mutex);
    signal(empty);
    compute data in nextc;
    until false;
    end

>b. Var empty, full: semaphore:=1, 0;
    
    gather:
    begin
    repeat
    ……
    gather data in nextp;
    wait(empty);
    buffer:=nextp;
    signal(full);
    until false;
    end
    compute:
    begin
    repeat
    ……
    wait(full);
    nextc:=buffer;
    signal(empty);
    compute data in nextc;
    until false;
    end

### 14．画图说明管程由哪几部分组成，为什么要引入条件变量？

答：管程由四部分组成：

* ①管程的名称；

* ②局部于管程内部的共享数据结构说明；

* ③对该数据结构进行操作的一组过程；

* ④对局部于管程内部的共享数据设置初始值的语句；
 
当一个进程调用了管程，在管程中时被阻塞或挂起，直到阻塞或挂起的原因解除，而在此期间，如果该进程不释放管程，则其它进程无法进入管程，被迫长时间地等待。为了解决这个问题，引入了条件变量condition。

### 15．如何利用管程来解决生产者与消费者问题？

答：首先建立一个管程，命名为ProclucerConsumer，包括两个过程：

* （1）Put（item）过程。生产者利用该过程将自己生产的产品放到缓冲池，用整型变量count 表示在缓冲池中已有的产品数目，当count≥n 时，表示缓冲池已满，生产者须等待。

* （2）get（item）过程。消费者利用该过程从缓冲池中取出一个产品，当count≤0时，表示缓冲池中已无可取的产品，消费者应等待。

>PC 管程可描述如下：

    type producer-consumer =monitor
    Var in,out,count:integer;
    buffer:array[0,…,n-1]of item;
    notfull，notempty:condition;
    procedure entry dot(item)
    begin
    if count>=n then not full.wait;
    buffer(in):=nextp;
    in:=(in+1)mod n;
    count:=count+1;
    if notempty.queue then notempty.signal;
    end
    procedure entry get(item)
    begin
    if count<=0 then not full.wait;
    nextc:=buffer(out);
    out:=(out+1)mod n;
    count:=count-1;
    if notfull.quene then notfull.signal;
    end
    begin in:=out:=0;
    count:=0
    end

>在利用管程解决生产者一消费者问题时，其中的生产者和消费者可描述为：

    producer: begin
    pepeat
    produce an inem in nestp
    PC.put(item);
    until false;
    end
    consumer: begin
    repeat
    PC.get(item);
    consume the item in enxtc;
    until false;
    end

### 16．什么是AND信号量？试利用AND信号量写出生产者一消费者问题的解法。

答：为解决并行带来的死锁问题，在wait 操作中引入AND 条件，其基本思想是将进程在整个运行过程中所需要的所有临界资源，一次性地全部分配给进程，用完后一次性释放。

>解决生产者－消费者问题可描述如下:

    var mutex,empty,full: semaphore:=1,n,0;
    buffer: array[0,...,n-1] of item;
    in,out: integer:=0,0;
    begin
    parbegin

>producer: 

    begin
    repeat
    …
    produce an item in nextp;
    …
    wait(empty);
    wait(s1,s2,s3,...,sn); //s1,s2,...,sn为执行生产者进程除empty外其余的条件
    wait(mutex);
    buffer(in):=nextp;
    in:=(in+1) mod n;
    signal(mutex);
    signal(full);
    signal(s1,s2,s3,...,sn);
    until false;
    end

>consumer: 

    begin
    repeat
    wait(full);
    wait(k1,k2,k3,...,kn); //k1,k2,...,kn 为执行消费者进程除full外其余的条件
    wait(mutex);
    nextc:=buffer(out);
    out:=(out+1) mod n;
    signal(mutex);
    signal(empty);
    signal(k1,k2,k3,...,kn);
    consume the item in nextc;
    until false;
    end
    parend
    end

### 17．什么是信号量集？试利用信号量集写出读者一写者问题的解法。

答：对AND信号量加以扩充，形成的信号量集合的读写机制。

    解法：Var RN integer;
    L,mx: semaphore:=RN,1;
    begin
    parbegin
    reader:begin
    repeat
    Swait(L,1,1);
    Swait(mx,1,1);
    …
    perform read operation;
    …
    Ssignal(L,1);
    until false
    end
    writer:begin
    repeat
    Swait(mx,1,1;L,RN,0);
    perform write operation;
    Ssignal(mx,1);
    until false
    end
    parend
    end


### 18．试比较进程间的低级与高级通信工具。

答：用户用低级通信工具实现进程通信很不方便，效率低，通信对用户不透明，所有操作都必须由程序员来实现，而高级通信工具弥补了这些缺陷，用户直接利用操作系统提供的一组通信命令，高效地传送大量的数据。

### 19．当前有哪几种高级通信机制？

答：共享存储器系统、消息传递系统以及管道通信系统。

### 20．消息队列通信机制有哪几方面的功能？

* （1）构成消息
* （2）发送消息
* （3）接收梢息
* （4）互斥与同步。

### 21. 为了在多线程OS中实现进程之间的同步与通信，通常提供了哪几种同步机制？

答：同步功能可以控制程序流并访问共享数据，从而并发执行多个线程。共有四种同步模型：互斥锁、读写锁、条件变量和信号。

### 22．用于实现线程同步的私用信号量和公用信号量之间有何差别？

* （1）私用信号量。当某线程需利用信号量实现同一进程中各线程之间的同步时，可调用创建信号量的命令来创建一个私用信号量，其数据结构存放在应用程序的地址空间中。
* （2）公用信号量。公用信号量是为实现不同进程间或不同进程中各线程之间的同步而设置的。其数据结构是存放在受保护的系统存储区中，由OS为它分配空间并进行管理。










































