# 银行家算法

### 一、死锁

* 定义：死锁是指两个或两个以上的进程在执行中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都无法推进下去，此时称系统处于死锁状态或系统产生了死锁。

	<div align="center"><img src="./img/死锁.png"/></div>

* 死锁的产生：
	* 1）：各进程竞争有限的资源；
    * 2）：进程之间的顺序推进不当。

* 死锁发生的必要条件是:
	* 互斥条件
	* 保持和等待条件
	* 不可剥夺条件
	* 环路等待条件

* 死锁的避免——银行家算法

* 死锁预防的方法：
	* (1)摈弃“请求和保持”条件,就是如果系统有足够资源,便一次性把进程需要的所有资源分配给它;
	* (2)摈弃“不剥夺”条件,就是已经拥有资源的进程,当它提出新资源请求而不能立即满足时,必须释放它已保持的所有资源,待以后需要时再重新申请;
	* (3)摈弃“环路等待”条件,就是将所有资源按类型排序标号,所有进程对资源的请求必须严格按序号递增的次序提出。

### 二、银行家算法的数据结构

* 可利用资源组(available)
* 进程最大需求矩阵(max)
* 分配矩阵(allocation)
* 需求矩阵(need)

	  need(i,j) = max(i,j) - allocation(i,j)

### 三、银行家算法

* (1) 如果 Request i[j]≤Need[i,j]，便转向步骤(2)；否则认为出错，因为它所需要的资源 数已超过它所宣布的最大值。 
* (2) 如果 Requesti[j]≤Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi 须 等待。 
* (3) 系统试探着把资源分配给进程 P i，并修改下面数据结构中的数值： 

	  Available[j] = Available[j] - Request i[j]； 
	  Allocation[i,j] = Allocation[i,j] + Request i[j]； 
	  Need[i,j] = Need[i,j] - Request i[j]； 

* (4) 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正 式将资源分配给进程 Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资 源分配状态，让进程 Pi等待。 

### 四、安全性算法 

>系统所执行的安全性算法可描述如下： 

* (1) 设置两个向量： 
	* ① 工作向量 Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有 m 个元素，在执行安全算法开始时，Work = Available。 
	* ② Finish，它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做 Finish[i] = false；当有足够资源分配给进程时，再令 Finish[i] = true。 
* (2) 从进程集合中找到一个能满足下述条件的进程：  
	* ① Finish[i] = false； 
	* ② Need[i,j] ≤ Work[j]；若找到，执行步骤(3)，否则，执行步骤(4)。 
* (3) 当进程 Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应 执行：
 
	  Work[j] = Work[j]+Allocation[i,j]； 
	  Finish[i] = true； 
	  go to step 2； 

* (4) 如果所有进程的 Finish[i]=true 都满足，则表示系统处于安全状态；否则，系统处于 不安全状态。 


